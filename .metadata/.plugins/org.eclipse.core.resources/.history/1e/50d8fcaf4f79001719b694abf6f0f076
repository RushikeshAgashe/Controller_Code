#include "DSP2833x_Device.h"     // DSP2833x Headerfile Include File
#include "DSP2833x_Examples.h"   // DSP2833x Examples Include File
#include "motor_control.h"
#include "extern_variable.h"
#include "DSP2833x_Project.h"
#include "string.h"
#include "SPLL_3ph_SRF_IQ.h"
#include "math.h"




signed int Duty_A,Duty_B,Duty_C,Duty_L1=0,Duty_L2=0,Duty_L3=0,Duty_DC,pwmc;
FLT32 V_out=0,V_ref1=0, V_ref2=0,V_ref4=0, I_L1, I_L2;
FLT32 Ki_vc1,Kp_vc1,Integ_v1=0, Kp_ic1, Ki_ic1, Integ_i1=0;
FLT32 Ki_vc2,Kp_vc2,Integ_v2=0, Kp_ic2, Ki_ic2, Integ_i2=0;
FLT32 Ki_vc3,Kp_vc3,Integ_v3=0, Kp_ic3, Ki_ic3, Integ_i3=0;
FLT32 Ki_vc4,Kp_vc4,Integ_v4=0, Kp_ic4, Ki_ic4, Integ_i4=0;

FLT32 I_a,I_b,I_c;
FLT32 V_a,V_b,V_c;
FLT32 V_DCDC,I_DCDC;
FLT32 output1[100],output2[100],output3[100];

FLT32 err_v1=0, err_i1=0;
FLT32 err_v2=0, err_i2=0;
FLT32 err_v4=0, err_i4=0;


FLT32 V_C2=0, V_2;

FLT32 Control_V1=0, Control_I1=0;
FLT32 Control_V2=0, Control_I2=0;
FLT32 Control_V4=0, Control_I4=0;


// MPPT Converter Variables

FLT32 Control_V3, Control_I3;
FLT32 err_v3=0, err_i3=0;
FLT32 V_ref3=810;
FLT32 I_L3, V_C3=0, V_In3, P_3, prev_P_3 = 0;
UINT16 MPPT_counter = 0;


// Droop Control Variables

FLT32 Vdc_max1, Vdc_min1, Rd1;
FLT32 Idis_max1, Icharge_max1;


FLT32 Vdc_max2, Vdc_min2, Rd2;
FLT32 Idis_max2, Icharge_max2;


FLT32 Vdc_max4, Vdc_min4, Rd4;
FLT32 Idis_max4, Icharge_max4;

UINT16 V_1;
UINT16 I_1;
UINT16 I_2;
UINT16 V_3;
UINT16 I_3;
UINT16 V_In_pv;
UINT16 I_In_a;
UINT16 I_In_b;
UINT16 I_In_c;
UINT16 V_In_a;
UINT16 V_In_b;
UINT16 V_In_c;
UINT16 V_In_DCDC;
UINT16 I_In_DCDC;


FLT32 Theta_ref;

// Inverter Controller

FLT32 Kp_d_1 = 5;
FLT32 Kp_q_1 = 5;
FLT32 Ki_d_1 = 15;
FLT32 Ki_q_1 = 15;

FLT32 Kp_d_2 = 0.01;
FLT32 Kp_q_2 = 0.01;
FLT32 Ki_d_2 = 0.5;
FLT32 Ki_q_2 = 0.5;

FLT32 Vd_ref,Vq_ref,V_ref,Vd_ref_r,Vq_ref_r,Theta_ref,omega=TWO_PI*60,L_v,Id_ref_r=10,Iq_ref_r;
FLT32 err_d_1=0,err_q_1=0,Integ_d_1=0,Integ_q_1=0,Vd,Vq;
FLT32 err_d_2=0,err_q_2=0,Integ_d_2=0,Integ_q_2=0;
FLT32 err_PD=0,err_QD=0,Integ_PD=0,Integ_QD=0;

FLT32 err_d=0,err_q=0,Integ_d=0,Integ_q=0,Vd,Vq;
FLT32 Control_Vd, Control_Vq;

FLT32 Control_Vd_1, Control_Vq_1;
FLT32 Control_Vd_2, Control_Vq_2;


ABC_DQ0_POS_IQ Vgrid_Spll;

ABC Vcmd,Vcmdn,Ireal,Vgrid;
DQS Vcmds,Ireals,Vgrids;
DQE Vcmde,Ireale,Icmde,Vgride;

int k=0,PWM_Counter,PWM_Count,Sample_Rate=1000;

int ISR_FREQ=3750*2;
int GRID_FREQ=60;
SPLL_3ph_SRF_IQ spll1;

interrupt void epwm1_timer_isr(void);
interrupt void  adc_isr(void);

DQS Is_abc2dqs(ABC *abc);
DQE Is_dqs2dqe(DQS *dqs, FLT32 COSTH, FLT32 SINTH);
DQS Is_dqe2dqs(DQE *dqe, FLT32 Theta_Q15_Ori);
ABC Is_dqs2abc(DQS *dqs);

void Is_SVPWM(void);
void InitVariable(void);
void SPWM_3ph(void);
void Three_phase_Inverter_Control(void);
void main(void)



{
    InitSysCtrl();
	Gpio_select();	  	
	InitPieCtrl();  // Disable PIE and clear PIEIER and PIEIFR registers
	IER = 0x0000;
	IFR = 0x0000;
	InitPieVectTable();  // Initialize and enable PIE vector table


	InitEPWM();

    SPLL_3ph_SRF_IQ_init(GRID_FREQ,(1.0/ISR_FREQ),&spll1); //PLL


	EALLOW;
	PieVectTable.EPWM1_INT = &epwm1_timer_isr;	
	PieVectTable.ADCINT = &adc_isr;

	EDIS; 
	
	SetupADC();	 

	IER |= M_INT1;
	IER |= M_INT3;
	
	PieCtrlRegs.PIECTRL.bit.ENPIE = 1;
	PieCtrlRegs.PIEIER3.bit.INTx1 = 1;	//EPWM1
	PieCtrlRegs.PIEIER1.bit.INTx6 = 1;	//ADC
	
	EINT;	

}



// Battery Converter 1

void CurrentControl_1(void)
{

    Kp_ic1=1;
    Ki_ic1=5;
    err_i1 = Control_V1-I_L1;

   Integ_i1 = (Integ_i1 + Ki_ic1*Tsampcc*err_i1);
   Control_I1 = Kp_ic1*err_i1 + Integ_i1 ;

}

void VoltageControl_1(void)
{

    // Virtual Resistance Calculator
    Vdc_max1=400;
    Vdc_min1=360;
    Idis_max1=80;
    Icharge_max1=80;
    Rd1= (Vdc_max1-Vdc_min1)/(Idis_max1+Icharge_max1);


    V_ref1=(380-Rd1*I_L1);
    Kp_vc1=0.01;
    Ki_vc1=2.5;
    err_v1 = V_ref1-V_out;

    Integ_v1 = (Integ_v1 + Ki_vc1*Tsampcc*err_v1);
    Control_V1 = Kp_vc1*err_v1+Integ_v1;

}

// Battery Converter 2

void CurrentControl_2(void)
{

        Kp_ic2=1;
        Ki_ic2=5;
        err_i2 = Control_V2-I_L2;

       Integ_i2 = (Integ_i2 + Ki_ic2*Tsampcc*err_i2);
       Control_I2 = Kp_ic2*err_i2 + Integ_i2;

}

void VoltageControl_2(void)
{

    // Virtual Resistance Calculator
    Vdc_max2=400;
    Vdc_min2=360;
    Idis_max2=80;
    Icharge_max2=80;
    Rd2= (Vdc_max2-Vdc_min2)/(Idis_max2+Icharge_max2);



    V_ref2=(380-Rd2*I_L2);
    Kp_vc2=0.01;
    Ki_vc2=1.5;
    err_v2 = V_ref2-V_out;

    Integ_v2 = (Integ_v2 + Ki_vc2*Tsampcc*err_v2);
    Control_V2 = Kp_vc2*err_v2 + Integ_v2;

}


// Buck MPPT Converter

void CurrentControl_3(void)
{

    Kp_ic3=1;
    Ki_ic3=2;
    err_i3 = Control_V3-I_L3;

   Integ_i3 = (Integ_i3 + Ki_ic3*Tsampcc*err_i3);
   Control_I3 = Kp_ic3*err_i3 + Integ_i3;

}

void VoltageControl_3(void)
{

   // V_ref3=25; Moved to Init.c
    Kp_vc3=0.01;
    Ki_vc3=1.5;
    err_v3 = V_In3-800;

    Integ_v3 = (Integ_v3 + Ki_vc3*Tsampcc*err_v3);
    Control_V3 = Kp_vc3*err_v3 + Integ_v3;

}

//void MPPT(FLT32 P_3)
//{
   // enum Directions{POSITIVE, NEGATIVE};
//    volatile static enum Directions direction  = POSITIVE;
//
//    switch(direction){
//    case POSITIVE:
//        if (P_3 > prev_P_3){
//            V_ref3 = V_ref3 + 2;
//            direction = POSITIVE;
//        }
//        else if (P_3 < prev_P_3){
//            V_ref3 = V_ref3 - 2;
//            direction = NEGATIVE;
//        }
//
//    case NEGATIVE:
//        if (P_3 < prev_P_3){
//            V_ref3 = V_ref3 + 2;
//            direction = POSITIVE;
//        }
//        else if (P_3 > prev_P_3){
//            V_ref3 = V_ref3 - 2;
//            direction = NEGATIVE;
//        }
//    }
//    prev_P_3 = P_3;
//}



void CurrentControl_4(void)
{

        Kp_ic4=0.5;
        Ki_ic4=1.5;
        err_i4 = Control_V4-I_DCDC;

       Integ_i4 = (Integ_i4 + Ki_ic4*Tsampcc*err_i4);
       Control_I4 = Kp_ic4*err_i4 + Integ_i4;

}

void VoltageControl_4(void)
{

    // Virtual Resistance Calculator
    Vdc_max4=400;
    Vdc_min4=360;
    Idis_max4=80;
    Icharge_max4=80;
    Rd4= (Vdc_max4-Vdc_min4)/(Idis_max4+Icharge_max4);



    V_ref4=(380-Rd4*I_DCDC);
    Kp_vc4=0.01;
    Ki_vc4=1.5;
    err_v4 = V_ref4-V_out;

    Integ_v4 = (Integ_v4 + Ki_vc4*Tsampcc*err_v4);
    Control_V4 = Kp_vc4*err_v4 + Integ_v4;

}



void PWM_Duty(void)
{

    Duty_A =(signed int)3750*(Control_I1/100);
    Duty_B =(signed int)3750*(Control_I2/100);
    Duty_C =(signed int)3750*(Control_I3/100);

// Duty_DC =(signed int)3750*(Control_I4/100);

}



void Is_SVPWM(void)
{

    EPwm1Regs.CMPA.half.CMPA = Duty_A;      //PWM1A
    EPwm1Regs.CMPB=Duty_B;                  //PWM1B
    EPwm2Regs.CMPA.half.CMPA = Duty_C;      //PWM2A

    //Inverter PWMs

    EPwm2Regs.CMPB = Duty_L1;               //PWM2B
    EPwm3Regs.CMPA.half.CMPA = Duty_L2;     //PWM3A
    EPwm3Regs.CMPB = Duty_L3;               //PWM3B

    //Series DC/DC PWM

   EPwm4Regs.CMPA.half.CMPA = Duty_DC;     //PWM4A


}



void SPWM_3ph(void)

{

    Vcmds = Is_dqe2dqs(&Vcmde,Theta_ref);
    Vcmd = Is_dqs2abc(&Vcmds);


//      if(Vcmd.a > Vcmd.b)
//      {
//          Max = Vcmd.a;
//          Min = Vcmd.b;
//      }
//      else
//      {
//          Max = Vcmd.b;
//          Min = Vcmd.a;
//      }
//
//      if(Vcmd.c > Max)
//      {
//          Max = Vcmd.c;
//      }
//      if(Vcmd.c < Min)
//      {
//          Min = Vcmd.c;
//
//      Vcmd.a = Max;
////         Offset Voltage
//      OffsetVoltage = -(Max + Min)*0.5;
//
//      // Pole Voltage Reference
//      Vcmdn.a = Vcmd.a + OffsetVoltage;
//      Vcmdn.b = Vcmd.b + OffsetVoltage;
//      Vcmdn.c = Vcmd.c + OffsetVoltage;
//
//      Vdc_Half = 0.5*Vdc;
//      if(Vcmdn.a >= Vdc_Half)
//      {
//          Vcmdn.a = Vdc_Half;
//      }
//      if(Vcmdn.a <= -Vdc_Half)
//      {
//          Vcmdn.a = -Vdc_Half;
//      }
//
//      if(Vcmdn.b >= Vdc_Half) Vcmdn.b = Vdc_Half;
//      else if(Vcmdn.b <= -Vdc_Half) Vcmdn.b = -Vdc_Half;
//
//      if(Vcmdn.c >= Vdc_Half) Vcmdn.c = Vdc_Half;
//      else if(Vcmdn.c <= -Vdc_Half) Vcmdn.c = -Vdc_Half;

//        Duty_L1 =(signed int)3750*(0.5+Vcmd.a/V_DCDC);
//        Duty_L2 =(signed int)3750*(0.5+Vcmd.b/V_DCDC);
//        Duty_L3 =(signed int)3750*(0.5+Vcmd.c/V_DCDC);

}

void Three_phase_Inverter_Control(void)
{

    err_d_1 = Id - Id_ref_r;
    Integ_d_1 = (Integ_d_1 + Ki_d_1*Tsampcc*err_d_1);

    Control_Vd_1 = Kp_d_1*err_d_1 + Integ_d_1 ;


    err_q_1 = Iq-0;
    Integ_q_1 = (Integ_q_1 + Ki_q_1*Tsampcc*err_q_1);

    Control_Vq_1 = Kp_q_1*err_q_1 + Integ_q_1 ;



    if (Control_Vq_1 > (2*V_DCDC/4))
    {
        Control_Vq_1=2*V_DCDC/4;
    }
    if (Control_Vq_1 < (-2*V_DCDC/4))
    {
        Control_Vq_1=-2*V_DCDC/4;
    }

    if (Control_Vd_1 > (2*V_DCDC/4))
    {
        Control_Vd_1=2*V_DCDC/4;
    }
    if (Control_Vd_1 < (-2*V_DCDC/4))
    {
        Control_Vd_1 = -2*V_DCDC/4;
    }

//    Vcmde.de=Control_Vd_1;
//    Vcmde.qe=Control_Vq_1;

    Vcmde.de=Vd+Control_Vd_1;
    Vcmde.qe=Vq+Control_Vq_1;

    //---------------------------------------------


}




DQS Is_abc2dqs(ABC *abc)
{
    DQS Temp;
    Temp.ds = (2./3.)*(abc->a   -abc->b*0.5-abc->c*0.5);
    Temp.qs = ONE_OVER_ROOT3*(abc->b-abc->c);
    return Temp;
}

DQE Is_dqs2dqe(DQS *dqs, FLT32 COSTH, FLT32 SINTH)
{
    DQE Temp;
    Temp.de = COSTH * dqs->ds+SINTH*dqs->qs;
    Temp.qe = -SINTH *dqs->ds+COSTH*dqs->qs;
    return Temp;
}

DQS Is_dqe2dqs(DQE *dqe, FLT32 Theta_Q15_Ori)
{
    DQS     Temp;
    FLT32   Theta_Off=0.,SinTheta_Off=0.,CosTheta_Off=0.;

    Theta_Off = Theta_Q15_Ori;
    SinTheta_Off = SIN(Theta_Off,Theta_Off*Theta_Off);
    CosTheta_Off = COS(Theta_Off*Theta_Off);
    Temp.ds  = CosTheta_Off *dqe->de-SinTheta_Off*dqe->qe;
    Temp.qs  = SinTheta_Off *dqe->de+CosTheta_Off*dqe->qe;
    return Temp;
}

ABC Is_dqs2abc(DQS *dqs)
{
    ABC Temp;
    Temp.a =  dqs->ds;
    Temp.b = -0.5*(dqs->ds-ROOT3*dqs->qs);
    Temp.c = -(Temp.a+Temp.b);
    return Temp;
}




// Interrupt routines uses in this example:
interrupt void epwm1_timer_isr(void)
{
//pwmc++;
//output1[pwmc]=(FLT32)(Duty_L1);
//if(pwmc==99)
//{
//    pwmc==0;
//}

    // Clear INT flag for this timer
    EPwm1Regs.ETCLR.bit.INT = 1;

    // Acknowledge this interrupt to receive more interrupts from group 3
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP3;
}

interrupt void  adc_isr(void)
{

    PWM_Count++;
    V_1  = AdcMirror.ADCRESULT0;
    V_out = ((FLT32)(V_1-2047.5)*1000)/(2047.5); //

    I_1  = AdcMirror.ADCRESULT1;
    I_L1 = ((FLT32)(I_1-2047.5)*150)/(2047.5); //

    I_2  = AdcMirror.ADCRESULT2;
    I_L2 = ((FLT32)(I_2-2047.5)*150)/(2047.5); //

    I_3 = AdcMirror.ADCRESULT3;
    I_L3 = ((FLT32)(I_3-2047.5)*100)/(2047.5); //

    V_In_pv = AdcMirror.ADCRESULT4;
    V_In3 = ((FLT32)(V_In_pv-2047.5)*1100)/(2047.5); //


 // Inverter AC/DC

    I_In_a = AdcMirror.ADCRESULT5;
    I_a = ((FLT32)(I_In_a-2047.5)*40)/(2047.5); //

    I_In_b = AdcMirror.ADCRESULT6;
    I_b = ((FLT32)(I_In_b-2047.5)*40)/(2047.5); //

    I_In_c = AdcMirror.ADCRESULT7;
    I_c = ((FLT32)(I_In_c-2047.5)*40)/(2047.5); //

    V_In_a = AdcMirror.ADCRESULT8;
    V_a = ((FLT32)(V_In_a-2047.5)*500)/(2047.5); //

    V_In_b = AdcMirror.ADCRESULT9;
    V_b = ((FLT32)(V_In_b-2047.5)*500)/(2047.5); //

    V_In_c = AdcMirror.ADCRESULT10;
    V_c = ((FLT32)(V_In_c-2047.5)*500)/(2047.5); //


// Inverter second stage

    V_In_DCDC = AdcMirror.ADCRESULT11;
    V_DCDC = ((FLT32)(V_In_DCDC-2047.5)*1250)/(2047.5); //
  //  V_DCDC=V_DCDC*1000/15;


    I_In_DCDC = AdcMirror.ADCRESULT12;
    I_DCDC = ((FLT32)(I_In_DCDC-2047.5)*150)/(2047.5); //

    if(PWM_Count==2)
    {


        VoltageControl_1();
        CurrentControl_1();

        VoltageControl_2();
        CurrentControl_2();

        VoltageControl_3();
        CurrentControl_3();

        VoltageControl_4();
        CurrentControl_4();


        //PLL

        Vgrid_Spll.a = (V_a/387);
        Vgrid_Spll.b = (V_b/387);
        Vgrid_Spll.c =(V_c/387);
        Vgrid_Spll.sin=sin((spll1.theta[1]));
        Vgrid_Spll.cos=cos((spll1.theta[1]));

        ABC_DQ0_POS_IQ_MACRO(Vgrid_Spll);
        spll1.v_q[0] =(Vgrid_Spll.q);
        SPLL_3ph_SRF_IQ_FUNC(&spll1);


        Theta_ref=spll1.theta[1];


        Cos_Theta=cos(Theta_ref);
        Sin_Theta=sin(Theta_ref);

        // Transformation

        Ireal.a = I_a;
        Ireal.b = I_b;
        Ireal.c = I_c;
        Vgrid.a=V_a;
        Vgrid.b=V_b;
        Vgrid.c=V_c;


        Ireals = Is_abc2dqs(&Ireal);
        Ireale = Is_dqs2dqe(&Ireals, Cos_Theta, Sin_Theta);
        Id = Ireale.de;
        Iq = Ireale.qe;


        Vgrids = Is_abc2dqs(&Vgrid);
        Vgride = Is_dqs2dqe(&Vgrids, Cos_Theta, Sin_Theta);
        Vd = Vgride.de;
        Vq = Vgride.qe;


        //P_3 = V_C3*V_C3;
        //MPPT_counter++;
        // if (MPPT_counter > 50000){
        //  MPPT(P_3);
        //  MPPT_counter = 0;
        // }



        Three_phase_Inverter_Control();
        SPWM_3ph();

        PWM_Duty();
        Is_SVPWM();

        PWM_Count=0;
    }


// Reinitialize for next ADC sequence
    AdcRegs.ADCTRL2.bit.RST_SEQ1 = 1;         // Reset SEQ1
    AdcRegs.ADCST.bit.INT_SEQ1_CLR = 1;       // Clear INT SEQ1 bit
    PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;   // Acknowledge interrupt to PIE
}




void InitVariable(void)
{
   // Tsampcc=0.0001;

}

void SPLL_3ph_SRF_IQ_init(int Grid_freq,float DELTA_T, SPLL_3ph_SRF_IQ *spll_obj)
{
    spll_obj->v_q[0]=0;
    spll_obj->v_q[1]=0;
    spll_obj->ylf[0]=0;
    spll_obj->ylf[1]=0;
    spll_obj->fo=0;
    spll_obj->fn=Grid_freq;
    spll_obj->theta[0]=0;
    spll_obj->theta[1]=0;
    // loop filter coefficients for 20kHz
    spll_obj->lpf_coeff.B0_lf=166.9743;
    spll_obj->lpf_coeff.B1_lf=-166.266;
    spll_obj->lpf_coeff.A1_lf=-1.0;
    spll_obj->delta_T=DELTA_T;
}
void SPLL_3ph_SRF_IQ_FUNC(SPLL_3ph_SRF_IQ *spll_obj)
{
    //update v_q[0] before calling the routine
    //---------------------------------//
    // Loop Filter //
    //---------------------------------//
    spll_obj->ylf[0]=spll_obj->ylf[1]+(spll_obj->lpf_coeff.B0_lf*spll_obj->v_q[0])+(spll_obj->lpf_coeff.B1_lf*spll_obj->v_q[1]);
    spll_obj->ylf[1]=spll_obj->ylf[0];
    spll_obj->v_q[1]=spll_obj->v_q[0];
    spll_obj->ylf[0]=(spll_obj->ylf[0]>(200.0))?(200.0):spll_obj->ylf[0];
    //---------------------------------//
    // VCO //
    //---------------------------------//
    spll_obj->fo=spll_obj->fn+spll_obj->ylf[0];
    spll_obj->theta[0]=spll_obj->theta[1]+(spll_obj->fo*spll_obj->delta_T)*(2*3.1415926);
    if(spll_obj->theta[0]>(2*3.1415926))
        spll_obj->theta[0]=spll_obj->theta[0]-(2*3.1415926);
    spll_obj->theta[1]=spll_obj->theta[0];
}



//===========================================================================
// No more.
//===========================================================================
